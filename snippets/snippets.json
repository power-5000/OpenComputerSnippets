{
	/* 	snippet name | scope | prefix | body | description
		 The prefix is what is used to trigger the snippet 
		 the body will be expanded and inserted
		 Possible variables are: $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	*/
	
	/*  	"Snippet name": {
			"scope": "lua",
			"prefix": "shortcut",
			"body": [ the expansion	],
			"description": "test snippet"
		}
	*/
	
	
	
	
	//OC APIs--------------------------------- https://ocdoc.cil.li/api
		"OC API": {
			"scope": "lua",
			"prefix": "OpenComputer.API",
			"body": [
				"--https://ocdoc.cil.li/api ctrl+click to follow"
			],
			"description": "creates link to the OC APIS"
		},
		"OC API2": {
			"scope": "lua",
			"prefix": "OpenComputer.API.Component",
			"body": [
				"--https://ocdoc.cil.li/component ctrl+click to follow"
			],
			"description": "creates link to the OC component APIS"
		},
	
	
	
		// FIXME: buffer
	
	
	
		//colors
			"colors.white": {
				"scope": "lua",
				"prefix": "colors.white",
				"body": [
					"colors.white"
				],
				"description": "reference white:0"
			},
	
			"colors.orange": {
				"scope": "lua",
				"prefix": "colors.orange",
				"body": [
					"colors.orange"
				],
				"description": "reference orange:1"
			},
	
			"colors.magenta": {
				"scope": "lua",
				"prefix": "colors.magenta",
				"body": [
					"colors.magenta"
				],
				"description": "reference magenta:2"
			},
	
			"colors.lightblue": {
				"scope": "lua",
				"prefix": "colors.lightblue",
				"body": [
					"colors.lightblue"
				],
				"description": "reference light blue:3"
			},
	
			"colors.yellow": {
				"scope": "lua",
				"prefix": "colors.yellow",
				"body": [
					"colors.yellow"
				],
				"description": "reference yellow:4"
			},
	
			"colors.lime": {
				"scope": "lua",
				"prefix": "colors.lime",
				"body": [
					"colors.lime"
				],
				"description": "reference lime:5"
			},
	
			"colors.pink": {
				"scope": "lua",
				"prefix": "colors.pink",
				"body": [
					"colors.pink"
				],
				"description": "reference pink:6"
			},
	
			"colors.gray": {
				"scope": "lua",
				"prefix": "colors.gray",
				"body": [
					"colors.gray"
				],
				"description": "reference gray:7"
			},
	
			"colors.silver": {
				"scope": "lua",
				"prefix": "colors.silver",
				"body": [
					"colors.silver"
				],
				"description": "reference silver:8"
			},
	
			"colors.cyan": {
				"scope": "lua",
				"prefix": "colors.cyan",
				"body": [
					"colors.cyan"
				],
				"description": "reference cyan:9"
			},
	
			"colors.purple": {
				"scope": "lua",
				"prefix": "colors.purple",
				"body": [
					"colors.purple"
				],
				"description": "reference purple:10"
			},
	
			"colors.blue": {
				"scope": "lua",
				"prefix": "colors.blue",
				"body": [
					"colors.blue"
				],
				"description": "reference blue:11"
			},
	
			"colors.brown": {
				"scope": "lua",
				"prefix": "colors.brown",
				"body": [
					"colors.brown"
				],
				"description": "reference brown:12"
			},
	
			"colors.green": {
				"scope": "lua",
				"prefix": "colors.green",
				"body": [
					"colors.green"
				],
				"description": "reference green:13"
			},
	
			"colors.red": {
				"scope": "lua",
				"prefix": "colors.red",
				"body": [
					"colors.red"
				],
				"description": "reference red:14"
			},
	
			"colors.black": {
				"scope": "lua",
				"prefix": "colors.black",
				"body": [
					"colors.black"
				],
				"description": "reference black:15"
			},
	
	
	
		// component 
			"component.doc()": {
				"scope": "lua",
				"prefix": "component.doc()",
				"body": [
					"component.doc(${1:address, method})$0"
				],
				"description": "(address:string, method:string)\n:string \nReturns the documentation string for the method with the specified name of the component with the specified address, if any."
			},
	
			"component.invoke()": {
				"scope": "lua",
				"prefix": "component.invoke()",
				"body": [
					"component.invoke(${1:address, method})$0"
				],
				"description": "address:string, method[]:string)\n:...\nCalls the method on the component with the specified address, passing the remaining arguments as arguments to that method. Returns the result of the method call."
			},
	
			"component.list()": {
				"scope": "lua",
				"prefix": "component.list()",
				"body": [
					"component.list(${1:[filter[]})$0"
				],
				"description": "(filter:string[\"\",exact bool])\n:function \nReturns a table with all components currently attached to the computer, with address as a key and component type as a value."
			},
	
			"component.methods()": {
				"scope": "lua",
				"prefix": "component.methods()",
				"body": [
					"component.methods(${1:address})$0"
				],
				"description": "(address:string)\n:table\n Returns a table with the names of all methods provided by the component with the specified address. The names are the keys in the table, the values indicate whether the method is called directly or not."
			},
	
			"component.proxy()": {
				"scope": "lua",
				"prefix": "component.proxy()",
				"body": [
					"component.proxy(${1:address})$0"
				],
				"description": "(address:string)\n:table\nGets a 'proxy' object for a component that provides all methods the component provides as fields, so they can be called more directly."
			},
	
			"component.type()": {
				"scope": "lua",
				"prefix": "component.type()",
				"body": [
					"component.type(${1:address})$0"
				],
				"description": "(address:string)\n:string\nGet the component type of the component with the specified address."
			},
	
			"component.slot()": {
				"scope": "lua",
				"prefix": "component.slot()",
				"body": [
					"component.slot(${1:address})"
				],
				"description": "(address:string)\n:string\nUndocumented."
			},
	
			"component.fields()": {
				"scope": "lua",
				"prefix": "component.fields()",
				"body": [
					"component.fields(${1:address})$0"
				],
				"description": "(address:string)\n:string\nybdocumented."
			},
	
			"component.get()": {
				"scope": "lua",
				"prefix": "component.get()",
				"body": [
					"component.get(${1:address})$0"
				],
				"description": "(address:string[, componentType:string])\n:string | (nil, error:string)\nTries to resolve an abbreviated address to a full address. Returns the full address on success, or nil and an error message otherwise. Optionally filters by component type."
			},
	
			"component.isAvailable()": {
				"scope": "lua",
				"prefix": "component.isAvailable()",
				"body": [
					"component.isAvailable(${1:componentType})$0"
				],
				"description": "(componentType:string)\n:boolean\nChecks if there is a primary component of the specified component type."
			},
	
			"component.getPrimary()": {
				"scope": "lua",
				"prefix": "component.getPrimary()",
				"body": [
					"component.getPrimary(${1:componentType})$0"
				],
				"description": "(componentType:string)\n:table\nGets the proxy for the primary component of the specified type. Throws an error if there is no primary component of the specified type."
			},
	
			"component.setPrimary()": {
				"scope": "lua",
				"prefix": "component.setPrimary()",
				"body": [
					"component.setPrimary(${1:componentType},${2:address})$0"
				],
				"description": "(componentType:string, address:string)\n\nSets a new primary component for the specified component type. The address may be abbreviated, but must be valid if it is not nil. Triggers the component_unavailable and component_available signals if set to nil or a new value."
			},
	
	
	
		// computer
			"computer.address()": {
				"scope": "lua",
				"prefix": "computer.address()",
				"body": [
					"computer.address()"
				],
				"description": ":string\nThe component address of this computer."
			},
	
			"computer.tmpAddress()": {
				"scope": "lua",
				"prefix": "computer.tmpAddress()",
				"body": [
					"computer.tmpAddress()"
				],
				"description": ":string\nThe component address of the computer's temporary file system (if any), used for mounting it on startup."
			},
	
			"computer.freeMemory()": {
				"scope": "lua",
				"prefix": "computer.freeMemory()",
				"body": [
					"computer.freeMemory()"
				],
				"description": ":number\nThe amount of memory currently unused, in bytes. If this gets close to zero your computer will probably soon crash with an out of memory error."
			},
	
			"computer.totalMemory()": {
				"scope": "lua",
				"prefix": "computer.totalMemory()",
				"body": [
					"computer.totalMemory()"
				],
				"description": ":number\nThe total amount of memory installed in this computer, in bytes."
			},
	
			"computer.energy()": {
				"scope": "lua",
				"prefix": "computer.energy()",
				"body": [
					"computer.energy()"
				],
				"description": ":number\nThe amount of energy currently available in the network the computer is in. For a robot this is the robot's own energy/fuel level."
			},
	
			"computer.maxEnergy()": {
				"scope": "lua",
				"prefix": "computer.maxEnergy()",
				"body": [
					"computer.maxEnergy()"
				],
				"description": ":number\nThe maximum amount of energy that can be stored in the network the computer is in. For a robot this is the size of the robot's internal buffer."
			},
	
			"computer.uptime()": {
				"scope": "lua",
				"prefix": "computer.uptime()",
				"body": [
					"computer.uptime()"
				],
				"description": ":number\nThe time in real world seconds this computer has been running, measured based on the world time that passed since it was started - meaning this will not increase while the game is paused."
			},
	
			"computer.shutdown()": {
				"scope": "lua",
				"prefix": "computer.shutdown()",
				"body": [
					"computer.shutdown(${1|true,false|})"
				],
				"description": "([reboot:boolean])\n\nShuts down the computer. reboots the computer, if reboot is true."
			},
	
			"comnputer.getBootAddress()": {
				"scope": "lua",
				"prefix": "comnputer.getBootAddress()",
				"body": [
					"comnputer.getBootAddress()"
				],
				"description": ":string\nGet the address of the filesystem component from which to try to boot first."
			},
	
			"computer.setBootAddress()": {
				"scope": "lua",
				"prefix": "computer.setBootAddress()",
				"body": [
					"computer.setBootAddress(${1:address})$0"
				],
				"description": "(address:string)\n\nSet the address of the filesystem component from which to try to boot first. Call with nil/no arguments to clear"
			},
	
			"computer.runlevel()": {
				"scope": "lua",
				"prefix": "computer.runlevel()",
				"body": [
					"computer.runlevel()"
				],
				"description": "string|number\n Returns the current runlevel the computer is in. Current Runlevels in OpenOS are:\nSingle-User mode, no components or filesystems initialized yet\nSingle-User mode, filesystems and components initialized - OpenOS finished booting"
			},
	
			"computer.users()": {
				"scope": "lua",
				"prefix": "computer.users()",
				"body": [
					"computer.users()"
				],
				"description": ":string\n A list of all users registered on this computer, as a tuple. To iterate the result as a list, use table.pack on it, first."
			},
	
			"computer.addUser()": {
				"scope": "lua",
				"prefix": "computer.addUser()",
				"body": [
					"computer.addUser(${1:name})$0"
				],
				"description": "(name:string)\n:boolean|nil, string\nRegisters a new user with this computer. Returns true if the user was successfully added. Returns nil and an error message otherwise. The user must be currently in the game. The user will gain full access rights on the computer."
			},
	
			"computer.removeUser()": {
				"scope": "lua",
				"prefix": "computer.removeUser()",
				"body": [
					"computer.removeUser(${1:name})$0"
				],
				"description": "(name:string)\n:boolean\nUnregisters a user from this computer. Returns true if the user was removed, false if they weren't registered in the first place."
			},
	
			"computer.pushSignal()": {
				"scope": "lua",
				"prefix": "computer.pushSignal()",
				"body": [
					"computer.pushSignal(${1:name})$0"
				],
				"description": "(name:string[, ...])\n\nPushes a new signal into the queue. Signals are processed in a FIFO order. The signal has to at least have a name. Arguments to pass along with it are optional."
			},
	
			"computer.pullSignal()": {
				"scope": "lua",
				"prefix": "computer.pullSignal()",
				"body": [
					"computer.pullSignal(${1:{timeout})$0"
				],
				"description": "([timeout:number])\n:name, ...\n"
			},
	
			"computer.beep()": {
				"scope": "lua",
				"prefix": "computer.beep()",
				"body": [
					"computer.beep(${1:frequency)"
				],
				"description": "([frequency:string|number[,duration:number])\noutput beeps\nCauses the computer to produce a beep sound at frequency Hz for duration seconds. This method is overloaded taking a single string parameter as a pattern of dots . and dashes - for short and long beeps respectively."
			},
	
	
	
		//event
			"event.listen()": {
				"scope": "lua",
				"prefix": "event.listen()",
				"body": [
					"event.listen(${1:event}, ${2:callback})$0"
				],
				"description": "(event:string, callback:function)\n:boolean\nRegister a new event listener that should be called for events with the specified name.\nevent-name of the signal to listen to.\ncallback-the function to call if this signal is received. The function will receive the event name it was registered for as first parameter, then all remaining parameters as defined by the signal that caused the event. \n Returns: number, the event id which can be canceled via event.cancel, if the event was successfully registered, false if this function was already registered for this event type."
			},
	
			"event.ignore()": {
				"scope": "lua",
				"prefix": "event.ignore()",
				"body": [
					"event.ignore(${1:event}, ${2:callback})$0"
				],
				"description": "(event:string, callback:function)\n:boolean\nUnregister a previously registered event listener.\nevent-name of the signal to unregister.\ncallback-the function that was used to register for this event.\nReturns: true if the event was successfully unregistered, false if this function was not registered for this event type."
			},
	
			"event.timer()": {
				"scope": "lua",
				"prefix": "event.timer()",
				"body": [
					"event.timer(${1:interval}, ${2:callback})$0"
				],
				"description": "(interval:number, callback:function[, times:number])\n:number\nStarts a new timer that will be called after the time specified in interval.\ninterval-time in seconds between each invocation of the callback function. Can be a fraction like 0.05.\ncallback-the function to call.\ntimes-how many times the function will be called. If omitted the function will be called once. Pass math.huge for infinite repeat.\n Returns: a timer ID that can be used to cancel the timer at any time.\nNote: the timer resolution can vary. If the computer is idle and enters sleep mode, it will only be woken in a game tick, so the time the callback is called may be up to 0.05 seconds off."
			},
	
			"event.cancel()": {
				"scope": "lua",
				"prefix": "event.cancel()",
				"body": [
					"event.cancel(${1:timerId})$0"
				],
				"description": "(timerId:number):boolean\nCancels a timer previously created with event.timer.\ntimerId-a timer ID as returned by event.timer.\nReturns: true if the timer was stopped, false if there was no timer with the specified ID."
			},
	
			"event.pull()": {
				"scope": "lua",
				"prefix": "event.pull()",
				"body": [
					"event.pull()"
				],
				"description": "([timeout:number], [name:string], ...)\n:string, ...\nPulls and returns the next available event from the queue, or waits until one becomes available.\ntimeout-if passed the function will wait for a new event for this many seconds at maximum then returns nil if no event was queued during that time.\nname-an event pattern that will act as a filter. If given then only events that match this pattern will be returned. Can be nil in which case the event names will not be filtered. See string.match on how to use patterns.\n… - any number of parameters in the same order as defined by the signal that is expected. Those arguments will act as filters for the additional arguments returned by the signal. Direct equality is used to determine if the argument is equal to the given filter. Can be nil in which case this particular argument will not be filtered.\nFilter example:\nThe touch signal has the signature screenX:number, screenY:number, playerName:string\nTo only pull clicks by player “Steve” you'd do:event.pull(\"touch\", nil, nil, \"Steve\")"
			},
	
			"event.pullFiltered()": {
				"scope": "lua",
				"prefix": "event.pullFiltered()",
				"body": [
					"event.pullFiltered(${1:timeout}, ${2:filter})$0"
				],
				"description": "([timeout:number], [filter:function])\n:string, ... (Since 1.5.9)\nPulls and returns the next available event from the queue, or waits until one becomes available but allows filtering by specifying filter function.\ntimeout-if passed the function will wait for a new event for this many seconds at maximum then returns nil if no event was queued during that time.\nfilter-if passed the function will use it as a filtering function of events. Allows for advanced filtering."
			},
	
			"event.pullMultiple()": {
				"scope": "lua",
				"prefix": "event.pullMultiple()",
				"body": [
					"event.pullMultiple(${1:name})$0"
				],
				"description": "(...)\n:...(Since 1.5.9)\nAs its arguments pullMutliple accepts multiple event names to be pulled, allowing basic filtering of multiple events at once."
			},
	
			"event.onError()": {
				"scope": "lua",
				"prefix": "event.onError()",
				"body": [
					"event.onError(${1:message})$0"
				],
				"description": "(message: any)\n\nGlobal event callback error handler. If an event listener throws an error, we handle it in this function to avoid it bubbling into unrelated code (that only triggered the execution by calling event.pull). Per default, this logs errors into a file on the temporary file system.\nYou can replace this function with your own if you want to handle event errors in a different way."
			},
	
			"event.push()": {
				"scope": "lua",
				"prefix": "event.push()",
				"body": [
					"event.push(${1:name})$0"
				],
				"description": "(name:string[, ...])\n\nThis is only an alias to computer.pushSignal. This does not modify the arguments in any way. It seemed logical to add the alias to the event library because there is also an event.pull for signals."
			},
	
	
	
		// UUID 
			"uuid.next()": {
				"scope": "lua",
				"prefix": "uuid.next()",
				"body": [
					"uuid.next()"
				],
				"description": ":string\n Returns 128 bit random identifiers, represented as a hex value in a string grouped by 8, 4, 4, 4, and 12 hex characters, separated by dashes."
		},
	
	
	
		// FIXME: filesystem
		// FIXME: internet
		// FIXME: keyboard
		// TODO: note
		// FIXME: process
		// TODO: rc
		// TODO: robot
		// TODO: serialization
		// FIXME: shell
	
	
	
		// sides
			"sides.bottom": {
				"scope": "lua",
				"prefix": "sides.bottom",
				"body": [
					"sides.bottom"
				],
				"description": "references the bottom"
			},
	
			"sides.top": {
				"scope": "lua",
				"prefix": "sides.top",
				"body": [
					"sides.top"
				],
				"description": "references the top"
			},
	
			"sides.back": {
				"scope": "lua",
				"prefix": "sides.back",
				"body": [
					"sides.back"
				],
				"description": "references the back"
			},
	
			"sides.front": {
				"scope": "lua",
				"prefix": "sides.front",
				"body": [
					"sides.front"
				],
				"description": "reference the front"
			},
	
			"sides.right": {
				"scope": "lua",
				"prefix": "sides.right",
				"body": [
					"sides.right"
				],
				"description": "reference the right"
			},
	
			"sides.left": {
				"scope": "lua",
				"prefix": "sides.left",
				"body": [
					"sides.left"
				],
				"description": "reference the left"
			},
	
	
	
		// TODO: term
		// TODO: text
		// TODO: thread
		// TODO: transforms
		// TODO: unicode
		// FIXME: signals
		// TODO: component apis-------------------------- https://ocdoc.cil.li/component
		// TODO: 3D Printer
		// TODO: Abstract bus
		// TODO: access point
		// TODO: chunkloader
		// TODO: computer
		// TODO: crafting
		// TODO: data card
		// TODO: database
		// TODO: debug
		// TODO: drone
		// TODO: drive
		// TODO: eeprom
		// TODO: experience
		// TODO: filesystem
		// TODO: generator
		// TODO: geolyzer
		// TODO: GPU
		// TODO: hologram
		// TODO: internet
		// TODO: inventory
		// TODO: controller
		// TODO: leash
		// TODO: modem
		// TODO: motion sensor
		// TODO: navigation
		// TODO: net splliter
		// TODO: Piston
	
	
	
		//redstone
			"redstone.getInput()": {
				"scope": "lua",
				"prefix": "redstone.getInput()",
				"body": [
					"redstone.getInput(${1:side})$0"
				],
				"description": "(side:number)\n:number\n():table\nReturns current incoming (non-bundled) redstone values. getInput(side) returns the redstone level from the specified side. getInput() returns a table of redstone levels from all sides.\nNote that the table returned is zero based. That is because the keys of the table are the ordinal values of the sides, and sides.bottom is 0.\nNote also that the side is relative to the computer's orientation, i.e. sides.south is in front of the computer, not south in the world. Likewise, sides.left is to the left of the computer, so when you look at the computer's front, it'll be to your right.\nIf you use mods such as RedLogic the input may exceed the vanilla values of [0, 15]."
			},
	
			"redstone.getOutput()": {
				"scope": "lua",
				"prefix": "redstone.getOutput()",
				"body": [
					"redstone.getOutput(${1:side})$0"
				],
				"description": "(side:number)\n:number\n():table\nGets the currently set output on the specified side, or the set value of all sides if called with no arguments"
			},
	
			"redstone.setOutput()": {
				"scope": "lua",
				"prefix": "redstone.setOutput()",
				"body": [
					"redstone.setOutput(${1:side})$0"
				],
				"description": "(side:number, value:number):number\n(values:table):table\nSets the strength of the redstone signal to emit. Returns the old value. This can be an arbitrarily large number for mods that support this. The first variant of this method takes a side and the redstone strength to apply to just that side. setOutput(values) allows you to set the redstone strength of all sides (or a subset of sides) in a single call."
			},
	
			"redstone.getBundledInput()": {
				"scope": "lua",
				"prefix": "redstone.getBundledInput()",
				"body": [
					"redstone.getBundledInput(${1:side}, ${2:color})$0"
				],
				"description": "(side:number, color:number)\n:number\n(side:number):table\n():table\nLike getInput, but for bundled input, reading the value for the channel with the specified API/Colors.As of OC 1.3: only available on a tier two redstone card.\n(side, color) returns the strength of the incoming redstone value on the specified side on the specified color channel.\n(side) returns a table (Map[Int, Int] structure) of redstone values on the specified side in a bundled pack, indexed by color.\n() returns all redstone values, of all sides and all colors. It is a Map[Int, Map[Int, Int]] structure. The top level keys are in [0, 5] range, values of sides."
			},
	
			"redstone.getBundledOutput()": {
				"scope": "lua",
				"prefix": "redstone.getBundledOutput()",
				"body": [
					"redstone.getBundledOutput(${1:side}, ${2:color})$0"
				],
				"description": "(side:number, color:number)\n:number\n(side:number):table\n():table\nLike getOutput, but for bundled output, getting the values previously set that the device is emitting.\nAs of OC 1.3: only available on a tier two redstone card."
			},
	
			"redstone.setBundledOutput()": {
				"scope": "lua",
				"prefix": "redstone.setBundledOutput()",
				"body": [
					"redstone.setBundledOutput(${1:side}, ${2:color}, ${2:value})$0"
				],
				"description": "(side:number, color:number, value:number)\n:number\n(side:number, value:number)\n:number\n(value:number)\n:number\nLike setOutput, but for bundled output, setting the value for the channel with the specified API/Colors. Returns the previous values set. setBundledOutput(side, values) sets a pack of color-indexed redstone values, [0, 15]. colors.white is zero. The values table doesn't have to be contiguous, and values omitted are left unchanged. setBundledOutput(values) allows you to set redstone levels for any side and any color in a single api call. \nAs of OC 1.3: only available on a tier two redstone card."
			},
	
			"redstone.getComparatorInput()": {
				"scope": "lua",
				"prefix": "redstone.getComparatorInput()",
				"body": [
					"redstone.getComparatorInput(${1:side})$0"
				],
				"description": "(side:number)\n:number\nGet the comparator input on the specified side."
			},
	
			"redstone.getWirelessInput()": {
				"scope": "lua",
				"prefix": "redstone.getWirelessInput()",
				"body": [
					"redstone.getWirelessInput()"
				],
				"description": ":number\nGet the wireless redstone input.\nAdded in OC 1.3. Only available on tier two redstone cards."
			},
	
			"redstone.getWirelessOutput()": {
				"scope": "lua",
				"prefix": "redstone.getWirelessOutput()",
				"body": [
					"redstone.getWirelessOutput()"
				],
				"description": ":boolean\nGet the wireless redstone output.\nAdded in OC 1.3. Only available on tier two redstone cards."
			},
	
			"redstone.setWirelessOutput()": {
				"scope": "lua",
				"prefix": "redstone.setWirelessOutput()",
				"body": [
					"redstone.setWirelessOutput(${1|true,false|})$0"
				],
				"description": "(value:boolean)\n:boolean\nSet the wireless redstone output.\nadded in OC 1.3. Only available on tier two redstone cards."
			},
	
			"redstone.getWirelessFrequency()": {
				"scope": "lua",
				"prefix": "redstone.getWirelessFrequency()",
				"body": [
					"redstone.getWirelessFrequency()"
				],
				"description": ":number\nGet the currently set wireless redstone frequency.\nAdded in OC 1.3. Only available on tier two redstone cards."
			},
	
			"redstone.setWirelessFrequency()": {
				"scope": "lua",
				"prefix": "redstone.setWirelessFrequency()",
				"body": [
					"redstone.setWirelessFrequency(${1:frequency})$0"
				],
				"description": "(frequency:number)\n:number\nSet the wireless redstone frequency to use.\nAdded in OC 1.3. Only available on tier two redstone cards."
			},
	
			"redstone.getWakeThreshold()": {
				"scope": "lua",
				"prefix": "redstone.getWakeThreshold()",
				"body": [
					"redstone.getWakeThreshold()"
				],
				"description": ":number\nGets the current wake-up threshold."
			},
	
			"redstone.setWakeThreshold()": {
				"scope": "lua",
				"prefix": "redstone.setWakeThreshold()",
				"body": [
					"redstone.setWakeThreshold()"
				],
				"description": "(threshold:number)\n:number\nSets the wake-up threshold to the specified number."
			},

			// robot
			"robot.name()": {
				"scope": "lua",
				"prefix": "robot.name()",
				"body": [
					"robot.name()"
				],
				"description": ":string\nThe name of a Robot is set initially during it's creation and cannot be changed programmatically. However you can change it using an anvil if you want."
			},

			"robot.detect()": {
				"scope": "lua",
				"prefix": "robot.detect()",
				"body": [
					"robot.detect()"
				],
				"description": ":boolean, string\nDetects what is directly in front of the robot and returns if the robot could move through it as well as a generic description."
			},
	
			"robot.detectUp()": {
				"scope": "lua",
				"prefix": "robot.detectUp()",
				"body": [
					"robot.detectUp()"
				],
				"description": ":boolean, string\nAs robot.detect() except that it scans the block directly above the robot."
			},
	
	
			"robot.detectDown()": {
				"scope": "lua",
				"prefix": "robot.detectDown()",
				"body": [
					"robot.detectDown()"
				],
				"description": ":boolean, string\nAs robot.detect() except that it scans the block directly below the robot."
			},
			
			"robot.select()": {
				"scope": "lua",
				"prefix": "robot.select()",
				"body": [
					"robot.select(${1:slot})$0"
				],
				"description": "(slot:number)\n:number\nSelects the given inventory slot (if specified) and returns the current inventory slot."
			},

			"robot.inventorySize()": {
				"scope": "lua",
				"prefix": "robot.inventorySize()",
				"body": [
					"robot.inventorySize()"
				],
				"description": ":number\nReturns the amount of select-able internal robot inventory slots. To get the number of inventory upgrade use: x = robot.inventorySize() / 16."
			},
			"robot.count()": {
				"scope": "lua",
				"prefix": "robot.count()",
				"body": [
					"robot.count(${1:slot})$0"
				],
				"description": "(slot:number)\n:number\n Returns the amount of items currently in the specified or selected slot."
			},

			"robot.space()": {
				"scope": "lua",
				"prefix": "robot.space()",
				"body": [
					"robot.space(${1:slot})$0"
				],
				"description": "(slot:number)\n:number\nReturns the amount of items that can still be added to the specified slot until it is filled up."
			},
			
			"robot.transferTo()": {
				"scope": "lua",
				"prefix": "robot.transferTo()",
				"body": [
					"robot.transferTo(${1:[slot[]})$0"
				],
				"description": "(slot:number[,count number])\n:boolean\nMoves all or up to count items from the currently selected slot to the specified slot.\nReturns true if exchanging the content between those slots was successful, false otherwise."
			},

			"robot.compareTo()": {
				"scope": "lua",
				"prefix": "robot.compareTo()",
				"body": [
					"robot.compareTo(${1:slot})$0"
				],
				"description": "(slot:number)\n:boolean\nCompares the item of the currently selected slot to the item of the slot specified and returns whether they are equal or not."
			},

			"robot.compare()": {
				"scope": "lua",
				"prefix": "robot.compare()",
				"body": [
					"robot.compare()"
				],
				"description": ":boolean\nCompares the block in front of the robot with the item in the currently selected slot and returns whether they are the same or not."
			},

			"robot.compareUp()": {
				"scope": "lua",
				"prefix": "robot.compareUp()",
				"body": [
					"robot.compareUp(${1:slot})$0"
				],
				"description": ":boolean\nAs robot.compare just for the block directly above the robot"
			},

			"robot.compareDown()": {
				"scope": "lua",
				"prefix": "robot.compareDown()",
				"body": [
					"robot.compareDown(${1:slot})$0"
				],
				"description": ":boolean\nAs robot.compare just for the block directly below the robot"
			},

			"robot.drop()": {
				"scope": "lua",
				"prefix": "robot.drop()",
				"body": [
					"robot.drop(${1:count})$0"
				],
				"description": "(count:number)\n:boolean\nTries to drop items from the currently selected inventory slot in front of the robot.\nReturns true if at least one item was dropped, false otherwise."
			},

			"robot.dropUp()": {
				"scope": "lua",
				"prefix": "robot.dropUp()",
				"body": [
					"robot.dropUp(${1:count}$0)"
				],
				"description": "(count:number)\n:boolean\nAs robot.drop just for the block directly above the robot."
			},

			"robot.dropDown()": {
				"scope": "lua",
				"prefix": "robot.dropDown()",
				"body": [
					"robot.dropDown(${1:count}$0)"
				],
				"description": "(count:number)\n:boolean\nAs robot.drop just for the block directly below the robot."
			},

			"robot.suck()": {
				"scope": "lua",
				"prefix": "robot.suck()",
				"body": [
					"robot.suck(${1:count}$0)"
				],
				"description": "(count:number)\n:boolean\nTries to pick up items from directly in front of the robot and puts it into the selected slot or (if occupied) first possible slot.\nReturns true if at least one item was picked up, false otherwise."
			},

			"robot.suckUp()": {
				"scope": "lua",
				"prefix": "robot.suckUp()",
				"body": [
					"robot.suckUp(${1:count}$0)"
				],
				"description": "(count:number)\n:boolean\nAs robot.suck just for the block directly above the robot."
			},

			"robot.suckDown()": {
				"scope": "lua",
				"prefix": "robot.suckDown()",
				"body": [
					"robot.suckDown(${1:count}$0)"
				],
				"description": "(count:number)\n:boolean\nAs robot.suck just for the block directly below the robot."
			},

			"robot.place()": {
				"scope": "lua",
				"prefix": "robot.place()",
				"body": [
					"robot.place(${1:[side[]}$0)"
				],
				"description": "([side:number[,sneaky boolean]])\n:boolean[,string]\nTries to place the block in the currently selected inventory slot in front of the robot.\nReturns: true if an item could be placed, false otherwise. If placement failed, the secondary return parameter will describe why the placement failed."
			},

			"robot.placeUp()": {
				"scope": "lua",
				"prefix": "robot.placeUp()",
				"body": [
					"robot.placeUp(${1:[side[]}$0)"
				],
				"description": "([side:number[,sneaky boolean]])\n:boolean[,string]\nAs robot.place except that the robot tries to place the item into space directly above it."
			},

			"robot.placeDown()": {
				"scope": "lua",
				"prefix": "robot.placeDown()",
				"body": [
					"robot.placeDown(${1:[side[]}$0)"
				],
				"description": "([side:number[,sneaky boolean]])\n:boolean[,string]\nAs robot.place except that the robot tries to place the item into space directly below it."
			},

			"robot.durability()": {
				"scope": "lua",
				"prefix": "robot.durability()",
				"body": [
					"robot.durability()"
				],
				"description": ":number, number, number or nil, string\nReturns the durability of the item currently in the tool slot, followed by its current durability, followed by its maximum durability."
			},

			"robot.swing()": {
				"scope": "lua",
				"prefix": "robot.swing()",
				"body": [
					"robot.swing(${1:[side[]})"
				],
				"description": "([side:number[sneaky boolean]])\n:boolean[,string]\nMakes the robot use the item currently in the tool slot against the block or space immediately in front of the robot in the same way as if a player would make a left-click.\nReturns: true if the robot could interact with the block or entity in front of it, false otherwise. If successful the secondary parameter describes what the robot interacted with and will be one of 'entity', 'block' or 'fire'."
			},

			"robot.swingUp()": {
				"scope": "lua",
				"prefix": "robot.swingUp()",
				"body": [
					"robot.swingUp(${1:[side[]})"
				],
				"description": "([side:number[sneaky boolean]])\n:boolean[,string]\nAs robot.swing except that the block or entity directly above the robot will be the target."
			},

			"robot.swingDown()": {
				"scope": "lua",
				"prefix": "robot.swingDown()",
				"body": [
					"robot.swingDown(${1:[side[]})"
				],
				"description": "([side:number[sneaky boolean]])\n:boolean[,string]\nAs robot.swing except that the block or entity directly below the robot will be the target."
			},

			"robot.use()": {
				"scope": "lua",
				"prefix": "robot.use()",
				"body": [
					"robot.use(${1:[side[]})"
				],
				"description": "([side:number[sneaky boolean[duration number]]])\n:boolean[,string]\nAttempts to use the item currently equipped in the tool slot in the same way as if the player would make a right-click.\nReturns: true if the robot could interact with the block or entity in front of it, false otherwise. If successful the secondary parameter describes what the robot interacted with and will be one of 'blockactivated', 'itemplaced', 'iteminteracted' or 'itemused'."
			},

			"robot.useUp()": {
				"scope": "lua",
				"prefix": "robot.useUp()",
				"body": [
					"robot.useUp(${1:[side[]})"
				],
				"description": "([side:number[sneaky boolean[duration number]]])\n:boolean[,string]\nAs robot.use except that the item is used aiming at the area above the robot."
			},

			"robot.useDown()": {
				"scope": "lua",
				"prefix": "robot.useDown()",
				"body": [
					"robot.useDown(${1:[side[]})"
				],
				"description": "([side:number[sneaky boolean[duration number]]])\n:boolean[,string]\nAs robot.use except that the item is used aiming at the area below the robot."
			},

			"robot.forward()": {
				"scope": "lua",
				"prefix": "robot.forward()",
				"body": [
					"robot.forward()"
				],
				"description": ":boolean[,string]\nTries to move the robot forward.\nReturns: true if the robot successfully moved, nil otherwise."
			},

			"robot.back()": {
				"scope": "lua",
				"prefix": "robot.back()",
				"body": [
					"robot.back()"
				],
				"description": ":boolean[,string]\nAs robot.forward except that the robot tries to move backward"
			},

			"robot.up()": {
				"scope": "lua",
				"prefix": "robot.up()",
				"body": [
					"robot.up()"
				],
				"description": ":boolean[,string]\nAs robot.forward except that the robot tries to move upwards"
			},

			"robot.down()": {
				"scope": "lua",
				"prefix": "robot.down()",
				"body": [
					"robot.down()"
				],
				"description": ":boolean[,string]\nAs robot.forward except that the robot tries to move downwards"
			},

			"robot.turnLeft()": {
				"scope": "lua",
				"prefix": "robot.turnLeft()",
				"body": [
					"robot.turnLeft()"
				],
				"description": "Turns the robot 90° to the left."
			},

			"robot.turnRight()": {
				"scope": "lua",
				"prefix": "robot.turnRight()",
				"body": [
					"robot.turnRight()"
				],
				"description": "As robot.turnLeft except that the robot turns 90° to the right."
			},

			"robot.turnAround()": {
				"scope": "lua",
				"prefix": "robot.turnAround()",
				"body": [
					"robot.turnAround()"
				],
				"description": "This is the same as calling robot.turnRight twice."
			},

			"robot.tankCount()": {
				"scope": "lua",
				"prefix": "robot.tankCount()",
				"body": [
					"robot.tankCount()"
				],
				"description": ":number\nThe number of tanks installed in the robot."
			},

			"robot.selectTank()": {
				"scope": "lua",
				"prefix": "robot.selectTank()",
				"body": [
					"robot.selectTank(${1:tank}$0)"
				],
				"description": "(tank:number)\nSelect the specified tank. This determines which tank most operations operate on."
			},

			"robot.tankLevel()": {
				"scope": "lua",
				"prefix": "robot.tankLevel()",
				"body": [
					"robot.tankLevel(${1:[tank[]})"
				],
				"description": "([tank:number])\n:number\nThe the current fluid level in the specified tank, or, if none is specified, the selected tank."
			},

			"robot.tankSpace()": {
				"scope": "lua",
				"prefix": "robot.tankSpace()",
				"body": [
					"robot.tankSpace(${1:[tank[]})"
				],
				"description": "([tank:number])\n:number\nThe the remaining fluid capacity in the specified tank, or, if none is specified, the selected tank."
			},

			"robot.compareFluidTo()": {
				"scope": "lua",
				"prefix": "robot.compareFluidTo()",
				"body": [
					"robot.compareFluidTo(${1:tank})"
				],
				"description": "(tank:number)\n:boolean\nTests whether the fluid in the selected tank is the same as in the specified tank."
			},

			"robot.transferFluidTo()": {
				"scope": "lua",
				"prefix": "robot.transferFluidTo()",
				"body": [
					"robot.transferFluidTo(${1:tank})"
				],
				"description": "(tank:number[,count:number])\n:boolean\nTransfers the specified amount of fluid from the selected tank into the specified tank. If no volume is specified, tries to transfer 1000 mB."
			},
			
			"robot.compareFluid()": {
				"scope": "lua",
				"prefix": "robot.compareFluid()",
				"body": [
					"robot.compareFluid()"
				],
				"description": ":boolean\nTests whether the fluid in the selected tank is the same as in the world or the tank in front of the robot."
			},
			
			"robot.compareFluidUp()": {
				"scope": "lua",
				"prefix": "robot.compareFluidUp()",
				"body": [
					"robot.compareFluidUp()"
				],
				"description": ":boolean\nLike compareFluid, but operates on the block above the robot."
			},
			
			"robot.compareFluidDown()": {
				"scope": "lua",
				"prefix": "robot.compareFluidDown()",
				"body": [
					"robot.compareFluidDown()"
				],
				"description": ":boolean\nLike compareFluid, but operates on the block below the robot."
			},
			
			"robot.drain()": {
				"scope": "lua",
				"prefix": "robot.drain()",
				"body": [
					"robot.drain(${1:[count[]}$0)"
				],
				"description": "([count:number])\n:boolean\nExtracts the specified amount of fluid from the world or the tank in front of the robot. When no amount is specified, will try to drain 1000 mB. When the drained fluid is in the world and it cannot be fully stored in the selected tank, the operation fails, i.e. no fluid is lost."
			},
			
			"robot.drainUp()": {
				"scope": "lua",
				"prefix": "robot.drainUp()",
				"body": [
					"robot.drainUp(${1:[count[]}$0)"
				],
				"description": "([count:number])\n:boolean\nLike drain, but operates on the block above the robot."
			},
			
			"robot.drainDown()": {
				"scope": "lua",
				"prefix": "robot.drainDown()",
				"body": [
					"robot.drainDown(${1:[count[]}$0)"
				],
				"description": "([count:number])\n:boolean\nLike drain, but operates on the block below the robot."
			},
			
			"robot.fill()": {
				"scope": "lua",
				"prefix": "robot.fill()",
				"body": [
					"robot.fill(${1:[count[]}$0)"
				],
				"description": "([count:number])\n:boolean\nInjects the specified amount of fluid from the selected tank into the the world or the tank in front of the robot. When no amount is specified, will try to eject 1000 mB. When there is not enough fluid to fill a block, or the target tank does not have enough room, the operation fails, i.e. no fluid is lost."
			},
			
			"robot.fillUp()": {
				"scope": "lua",
				"prefix": "robot.fillUp()",
				"body": [
					"robot.fillUp(${1:[count[]}$0)"
				],
				"description": "([count:number])\n:boolean\nLike fill, but operates on the block above the robot."
			},

			"robot.fillDown()": {
				"scope": "lua",
				"prefix": "robot.fillDown()",
				"body": [
					"robot.fillDown(${1:[count[]}$0)"
				],
				"description": "([count:number])\n:boolean\nLike fill, but operates on the block below the robot."
			},
		// FIXME: screen
		// TODO: sign
		// TODO: tank controller
		// TODO: tractor beam
		// TODO: transposer
		// TODO: tunnel
		// TODO: world sensor
		// TODO: component access ------------------- https://ocdoc.cil.li/component:component_access
		// TODO: signals----------------------------- https://ocdoc.cil.li/component:signals
		
	
	
		// Applied Energistics
			"getCpus()": {
				"scope": "lua",
				"prefix": "getCpus()",
				"body": [
					"getCpus()"
				],
				"description": ":table\nGet a list of tables representing the available CPUs in the network."
			},
	
			"getCraftables()": {
				"scope": "lua",
				"prefix": "getCraftables()",
				"body": [
					"getCraftables(${1:filter})$0"
				],
				"description": "([filter:table])\n:table\nGet a list of known item recipes. These can be used to issue crafting requests."
			},
	
			"getItemsInNetwork()": {
				"scope": "lua",
				"prefix": "getItemsInNetwork()",
				"body": [
					"getItemsInNetwork(${1:filter})$0"
				],
				"description": "([filter:table]\n:table\nGet a list of the stored items in the network."
			},
	
			"store()": {
				"scope": "lua",
				"prefix": "store()",
				"body": [
					"store(${1:info})$0"
				],
				"description": "([filter:table,][dbAddress:string,][startSlot:number,][count:number])\n:bool\nStore items in the network matching the specified filter in the database with the specified address."
			},
	
			"getFluidsInNetwork()": {
				"scope": "lua",
				"prefix": "getFluidsInNetwork()",
				"body": [
					"getFluidsInNetwork()"
				],
				"description": ":table\n Get a list of the stored fluids in the network."
			},
	
			"getAvgPowerInjection()": {
				"scope": "lua",
				"prefix": "getAvgPowerInjection()",
				"body": [
					"getAvgPowerInjection()"
				],
				"description": ":number\nGet the average power injection into the network."
			},
	
			"getAvgPowerUsage()": {
				"scope": "lua",
				"prefix": "getAvgPowerUsage()",
				"body": [
					"getAvgPowerUsage()"
				],
				"description": ":number\nGet the average power usage of the network."
			},
	
			"getIdlePowerUsage()": {
				"scope": "lua",
				"prefix": "getIdlePowerUsage()",
				"body": [
					"getIdlePowerUsage()"
				],
				"description": ":number\nGet the idle power usage of the network."
			},
	
			"getMaxStoredPower()": {
				"scope": "lua",
				"prefix": "getMaxStoredPower()",
				"body": [
					"getMaxStoredPower()"
				],
				"description": ":number\nGet the maximum stored power in the network."
			},
	
			"getStoredPower()": {
				"scope": "lua",
				"prefix": "getStoredPower()",
				"body": [
					"getStoredPower()"
				],
				"description": ":number\nGet the stored power in the network."
			},
			//ME Controller me_controller
			"getEnergyStored()": {
				"scope": "lua",
				"prefix": "getEnergyStored()",
				"body": [
					"getEnergyStored()"
				],
				"description": ":number\nReturns the amount of stored energy on the connected side."
			},
	
			"getMaxEnergyStored()": {
				"scope": "lua",
				"prefix": "getMaxEnergyStored()",
				"body": [
					"getMaxEnergyStored()"
				],
				"description": ":number\nReturns the maximum amount of stored energy on the connected side."
			},
	
			"canExtract()": {
				"scope": "lua",
				"prefix": "canExtract()",
				"body": [
					"canExtract()"
				],
				"description": ":number\n Returns whether this component can have energy extracted from the connected side."
			},
	
			"canReceive()": {
				"scope": "lua",
				"prefix": "canReceive()",
				"body": [
					"canReceive()"
				],
				"description": ":number\n Returns whether this component can receive energy on the connected side."
			},
			//Craftable - userdata objects returned from any ae2 network component getCraftables
			"getItemStack()": {
				"scope": "lua",
				"prefix": "getItemStack()",
				"body": [
					"getItemStack()"
				],
				"description": ":table\nReturns the item stack representation of the crafting result."
			},
	
			"request()": {
				"scope": "lua",
				"prefix": "request()",
				"body": [
					"request()"
				],
				"description": "([amount:int[,prioritizePower:boolean[,cpuName:string]]])\n:userdata\nRequests the item to be crafted, returning an object that allows tracking the crafting status."
			},
			//CraftStatus - userdata objects returned from calling request on Craftable
			"isCanceled()": {
				"scope": "lua",
				"prefix": "isCanceled()",
				"body": [
					"isCanceled()"
				],
				"description": ":Boolean\nGet whether the crafting request has been canceled."
			},
	
			"isDone()": {
				"scope": "lua",
				"prefix": "isDone()",
				"body": [
					"isDone()"
				],
				"description": ":Boolean\nGet whether the crafting request is done."
			},
			//ME_Interface - The me_interface provides the Common Network API and the following
			"getInterfaceConfiguration()": {
				"scope": "lua",
				"prefix": "getInterfaceConfiguration()",
				"body": [
					"getInterfaceConfiguration(${1:slot})$0"
				],
				"description": "([slot:number])\n:table\nGet the configuration of the interface."
			},
	
			"setInterfaceConfiguration()": {
				"scope": "lua",
				"prefix": "setInterfaceConfiguration()",
				"body": [
					"setInterfaceConfiguration(${1:info})$0"
				],
				"description": "([slot:number][, database:address, entry:number[, size:number]])\n:boolean\nConfigure the interface."
			},
			//ME_ImportBus - The me_importbus provides the Common Network API and the following:
			"getImportConfiguration()": {
				"scope": "lua",
				"prefix": "getImportConfiguration()",
				"body": [
					"getImportConfiguration(${1:side, slot})$0"
				],
				"description": "(side:number[, slot:number])\n:boolean\nGet the configuration of the import bus pointing in the specified direction."
			},
	
			"setImportConfiguration()": {
				"scope": "lua",
				"prefix": "setImportConfiguration()",
				"body": [
					"setImportConfiguration(${1:info})$0"
				],
				"description": "(side:number[, slot:number][, database:address, entry:number])\n:boolean\nConfigure the import bus pointing in the specified direction to import item stacks matching the specified descriptor."
			},
			//ME_ExportBus - The me_exportbus provides the Common Network API and the following:
			"getExportConfiguration()": {
				"scope": "lua",
				"prefix": "getExportConfiguration()",
				"body": [
					"getExportConfiguration(${1:side,slot})$0"
				],
				"description": "(side:number, [ slot:number])\n:boolean\nGet the configuration of the export bus pointing in the specified direction."
			},
	
			"setExportConfiguration()": {
				"scope": "lua",
				"prefix": "setExportConfiguration()",
				"body": [
					"setExportConfiguration(${1:info})$0"
				],
				"description": "(side:number[, slot:number][, database:address, entry:number)\n:boolean\nConfigure the export bus pointing in the specified direction to export item stacks matching the specified descriptor."
			},
	
			"exportIntoSlot()": {
				"scope": "lua",
				"prefix": "exportIntoSlot()",
				"body": [
					"exportIntoSlot(${1:side,slot})$0"
				],
				"description": "(side:number, slot:number)\n:boolean\nMake the export bus facing the specified direction perform a single export operation into the specified slot."
			}
	
	
	}
